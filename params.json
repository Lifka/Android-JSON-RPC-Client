{
  "name": "Android-rpc",
  "tagline": "How to create a RPC client for Android that connect with RPC Linux Server ",
  "body": "# RPC en Android (android-json-rpc)\r\n\r\n\r\nGallardo Morales, Juan Carlos (jcgallardomorales@gmail.com)  \r\nIzquierdo Vera, Javier (javierizquierdovera@gmail.com)\r\n\r\n# Abstract \r\nRPC permite conectar dispositivos, pudiendo realizar una conexión\r\ncliente servidor. En este texto se pretende usar esta tecnología para desarrollar un\r\ncliente en Android que permita a una aplicación móvil utilizar servicios RPC.\r\nPara este propósito se ha seleccionado y utilizado una biblioteca que sigue el\r\nformato JSON para la serialización de los datos. Se habla acerca de la biblioteca,\r\nde sus funcionalidades, de su instalación, y concluímos llevándolo a la práctica\r\nmediante el desarrollo de un pequeño ejemplo de cliente.\r\n\r\n# Introducción\r\nRPC (Remote Procedure Call), en resumidas palabras, es una técnica de programación\r\ndistribuida cuya finalidad principal es abstraer la comunicación entre dos equipos in-\r\nformáticos por medio de un middleware con la intención de ejecutar procedimientos\r\nremotos de otra máquina sin preocuparnos en cómo se establece la comunicación. Esta\r\nidea puede aplicarse sobre cualquier dispositivo, y para ello hay varios ejemplos de\r\nentornos RPC tales como Java-RMI, SOAP, CORBA, etc. [1,2]\r\nActualmente no tiene mucho sentido utilizar esta tecnología en dispositivos Android ya\r\nque se está desarrollando muy rápidamente la arquitectura REST (concretamente\r\nRESTful) donde se desarrollan servicios web listos para su uso desde cualquier otro\r\ndispositivo, algo que resulta muy cómo para programar aplicaciones cliente de forma\r\nmuy rápida. Para ello el dispositivo cliente tan solo tiene que conectarse a un servidor\r\nweb que ofrezca dicho servicio para invocarlo y poder usar el resultado devuelto. Dicho\r\nresultado podrá estar en diferentes formatos, de los cuales destacamos XML y JSON\r\n[3].\r\nSi nuestro objetivo es ejecutar procedimientos de otra máquina en nuestro dispositivo\r\nAndroid, sin tener que depender de ningún servicio ofrecido en la web, tenemos dispo-\r\nnibles varias bibliotecas que nos ofrecen una forma de implementar RPC en Android\r\nde forma muy sencilla. Concretamente vamos a centrarnos en una de las bibliotecas\r\nopen Source más conocidas en la actualidad en cuanto a llamadas a procedimientos\r\nremotos se refiere, denominada Android-rpc-json. Como su nombre indica trata de\r\nfacilitarnos el uso de RPC en Android por medio del formateo de datos en JSON [10].\r\n\r\n# Trabajos Relacionados\r\nActualmente existen muchas bibliotecas relacionadas con Android-rpc-json, entre\r\nlas que destacamos las siguientes:\r\n\r\n* XML-RPC: es un protocolo de llamadas a procedimientos remotos (RPC) que\r\ntrabaja sobre internet devolviendo los resultados en formato XML. Fue el co-\r\nmienzo de lo que hoy en día es conocido como SOAP. Actualmente parece\r\nestar bastante abandonado debido a su gran simplicidad, y por esta razón mu-\r\nchos desarrolladores han optado por crear nuevas bibliotecas a partir de esta\r\npara intentar solucionar los problemas que presenta, como aXMLRPC [4,5].\r\n* Apache XML-RPC: adaptación XML-RPC al lenguaje Java realizado por\r\nApache Software Foundation. La web oficial fue editada por última vez en el\r\naño 2005, por lo que parece no estar en desarrollo actualmente. En dicha web\r\nexiste una API muy extensa para su uso y podemos acceder directamente a su\r\ndescarga de forma gratuita [6].\r\n* Android-xmlrpc: se trata de otra adaptación de XML-RPC a dispositivos An-\r\ndroid, caracterizada por ser muy ligera. Hay muy poca información sobre ella\r\ny muy pocos ejemplos prácticos sobre su utilización. Desde code.google.com\r\npodemos ver que su última actualización fue subida en el año 2010, y su último\r\ncommit fue en 2012 por lo que deja muchas dudas sobre su actual desarrollo\r\n[9].\r\n\r\n# 3 Análisis\r\n### 3.1 Descripción\r\nCentraremos nuestra atención en la biblioteca “android-json-rpc” [10] creada y man-\r\ntenida por una comunidad de usuarios bajo licencia MIT [11]. Como ya hemos men-\r\ncionado en apartados anteriores, hay varias bibliotecas y proyectos que han pretendido\r\ndar soporte a este concepto, el motivo por el que hemos seleccionado esta biblioteca en\r\nconcreto es porque ha sido mantenida hasta el año 2013. No es una fecha muy reciente\r\npero sí de las más recientes, además de que es una biblioteca que tiene claro su objetivo\r\ny se centra en él, por lo que no es demasiado grande y no tiene mucho más de lo que\r\nnecesitamos.    \r\nEsta biblioteca se centra exclusivamente en dar el soporte necesario para crear un\r\ncliente RPC en plataformas Android, proporcionando los métodos adecuados para crear\r\nel cliente con el host concreto, y para enviar y recibir datos del servidor, usando para\r\nello el formato JSON, el cual se explicará más adelante. Todo ello se basa en JSON-\r\nRPC [7].\r\n###  3.2 Requerimientos y clases ofrecidas\r\nNo hay ningún requerimiento concreto para utilizar esta biblioteca, simplemente hay\r\nque incluirla en el proyecto Android e importarla para poder usar sus funciones. Lo único que tenemos que tener en cuenta es importar algunas utilidades de la biblioteca\r\nHTTP de apache que se requieren, lo cual no debería suponer un problema porque suele\r\nencontrarse en el entorno y es fácil de conseguir. Más tarde en el apartado de instalación se explicará cómo importar esta biblioteca.\r\n\r\nAndroid-json-rpc ofrece documentación en formato html de todas sus clases y métodos,\r\nalgo de lo que carecían algunas de las bibliotecas encontradas en Internet. Ésta biblioteca se compone de 7 clases principales: JSONEntity, JSONRPCClient, JSONRPCEx-\r\nception, JSONRPCHttpClient, JSONRPCParams, JSONRPCThreadedClient, y JSON-\r\nRPCThreadedHttpClient.\r\n\r\nVamos a ceñirnos a lo necesario para crear y hacer funcionar un cliente RPC por medio\r\nde esta biblioteca sin tener en cuenta todas las funciones incluidas, debido a que toda la documentación ya se encuentra detallada y sería redundante centrarnos en ello. La clases clases que utilizaremos son: JSONRPCClient, JSONRPCException y JSON-\r\nRPCParams. \r\n\r\nJSONRPCClient es la clase más importante, es la que compone la estructura del\r\ncliente (aunque también podríamos haber utilizado la clase JSONRPCHttpClient en\r\ncaso de realizarlo usando http). Contiene los métodos necesarios para registrar el host con el que se establece conexión (create), para establecer el timeout (setConnectionTimeout), consultarlo (getConnectionTimeout), establecer el timeout del socket (setSoTimeout), obtenerlo (getSoTimeout), etc.\r\n\r\nAdemás, también contiene los métodos que necesitaremos para realizar las peticiones\r\nal servidor, estos son los llamados métodos “call”. Hay un call distinto para diversos\r\ntipos de variables, callBoolean, callDouble, callInt, callString, callLong, callJSONA-\r\nrray, etc. Cada call devuelve el tipo de variable que se especifica en su sintaxis, y recibe el nombre del método (String) que se va a llamar en el servidor, y los parámetros que se requieren para ello, de modo que estos métodos realizan la petición al servidor y devuelven la respuesta en el tipo indicado. Con la excepción del propio método “call”, que devuelve un Object.\r\n\r\nJSONRPCException se ha utilizado para controlar la posible excepción en caso de\r\nque la llamada al servidor falle, y JSONRPCParams, que no es más que un enum, se ha\r\nutilizado para indicar la versión de JSON-RPC que utiliza el servidor, la cual es necesaria indicar al enlazar el host. En este caso se utilizará la versión 2 de JSON-RPC, que es la más reciente [7].\r\n\r\nToda esta información puede encontrarse más detallada en la documentación de la bi-\r\nblioteca [10].\r\n### 3.3 Formato de salida\r\nLos datos de salida están formateados en JSON, formato de texto ligero para inter-\r\ncambio de datos. Se trata de una alternativa mucho más eficiente que XML y es sopor-\r\ntada y apoyada directa o indirectamente por casi todos los lenguajes de programación\r\nmodernos. Su estructura básica es la siguiente:\r\n- Colección de pares nombre / valor, que puede estar representada por objetos,\r\ntablas hash, listas con claves, etc.\r\n- Lista ordenada de valores, representada por matrices, vectores, arrays, etc.Su implementación, de forma resumida, es la siguiente:\r\n1. Objetos:     \r\n{string1: value1, string2: value2,...}\r\n2. Arrays:  \r\n[value1, value2,...]\r\n\r\nDonde value puede ser un objeto, array, booleano, número, string, null, etc.\r\nEn nuestro caso nos interesa utilizarlo en Java, lo que cual se realizaría de la siguiente forma: \r\n* Convertir objetos Java a JSON (serialización): podemos utilizar la librería Gson para facilitarnos el trabajo. Por ejemplo podríamos serializar de forma estándar de la siguiente forma:\r\n```java\r\nEmpleado emp = new Empleado();\r\nGson gson = new Gson();\r\nString representacion = gson.toJson(emp);\r\n```\r\n\r\n* Convertir JSON a objetos Java (deserialización): usando la misma librería (Gson)\r\npodemos convertir una cadena Json a objetos Java de forma muy sencilla, veamos\r\nun ejemplo de uso estándar:\r\n```java\r\nGson gson = new Gson();\r\nType tipoEmp = new TypeToken<Empleado>().getType();\r\nEmp = gson.fromJson(representación,tipoEmp);\r\n```\r\n\r\nPodemos ver más información de Json en [7] y más información de Gson en [8].\r\n### 3.4 Instalación\r\nComo se ha mencionado anteriormente, la instalación es relativamente sencilla y se\r\nlimita a descargar las bibliotecas e importarlas en el proyecto Android. En la web de la biblioteca android-json-rpc se habla de cómo importarla en eclipse [12], esto es debido a que no está actualizado, nosotros desaconsejamos el uso de eclipse para esta labor y a continuación explicaremos cómo importarla en Android Studio.\r\n\r\nUna vez tengamos Android Studio y el proyecto Android cargado (la explicación de\r\ncómo se realiza la instalación y la creación del proyecto escapa del objetivo de este\r\ntexto), y hayamos descargado la biblioteca desde su web, nos situamos en la estruc-\r\ntura del proyecto (File → Project Structure...) y añadimos las dependencias requeridas\r\nmediante el botón “Add”. Otra alternativa es arrastrar las clases de java a la carpeta denuestro proyecto. Una vez realizado esto tendremos que especificar los “import” ne-\r\ncesarios en el código, indicando el paquete y la clase. Por ejemplo, en caso de haber-\r\nlos importado en el paquete “RPC”, habría que indicar “import RPC.clase_concreta;”.\r\nEl proceso para importar las clases requeridas de Apache HTTP sería análogo, la bi-\r\nblioteca la podemos encontrar en la web de Apache [13].\r\n\r\n### 3.5 Ejemplo de uso\r\nSiguiendo el proceso de instalación mencionado, y utilizando las clases y métodos que\r\nse han explicado, se ha realizado un ejemplo sencillo de aplicación Android que suma\r\ndos números en un servidor remoto. Para ello la aplicación solicita al usuario iniciar el cliente, el cual se ha abstraído de la aplicación tratándose como un objeto, intentando reducir el acoplamiento entre ambos. Una vez iniciado el cliente, el usuario puede introducir dos números cualesquiera y pulsar el botón de sumar, este botón llama a un método del objeto cliente el cual llama al método “call” indicando los dos números a sumar, y el método que se encarga de sumar en el servidor, recibiendo así una respuesta y devolviéndoselo a la clase java que se encarga de controlar los eventos del layout, mostrándolo así como un resultado visible en la pantalla del dispositivo.\r\n\r\nEjemplo de la interfaz de la aplicación:\r\n\r\n![Imagen 1](http://i.imgur.com/FUCmTkr.png \"\") \r\n![Imagen 1](http://i.imgur.com/lpESkaU.png \"\")\r\n\r\nEl código de la aplicación será el siguiente:\r\n```java\r\npackage com.red.lifka.rpc_android;\r\n\r\nimport android.support.v7.app.AppCompatActivity;\r\nimport android.os.Bundle;\r\nimport android.util.Log;\r\nimport android.view.View;\r\nimport android.widget.Button;\r\nimport android.widget.EditText;\r\nimport android.widget.TextView;\r\n\r\npublic class Main extends AppCompatActivity {\r\n\r\n   private Button start_client;\r\n   private EditText val1;\r\n   private EditText val2;\r\n   private TextView result_value;\r\n   private Button launch;\r\n\r\n   private Client client = null;\r\n   private double x;\r\n   private double y;\r\n   private double result = 0.0;\r\n   private int operation = 0;\r\n\r\n   private String host = \"localhost\";\r\n\r\n\r\n   @Override\r\n   protected void onCreate(Bundle savedInstanceState) {\r\n       super.onCreate(savedInstanceState);\r\n       setContentView(R.layout.activity_main);\r\n\r\n       // Enlazar objetos del layout\r\n       start_client = (Button)findViewById(R.id.startclient);\r\n       val1 = (EditText)findViewById(R.id.value1);\r\n       val2 = (EditText)findViewById(R.id.value2);\r\n       result_value = (TextView)findViewById(R.id.resultvalue);\r\n       launch = (Button)findViewById(R.id.launch);\r\n       launch.setEnabled(false);\r\n\r\n       // Iniciar cliente\r\n       start_client.setOnClickListener(new View.OnClickListener() {\r\n           @Override\r\n           public void onClick(View v) {\r\n               // Clase cliente, abstrae el uso del cliente que ofrece la biblioteca\r\n               client = new Client(host);\r\n\r\n               // Ajustar layout\r\n               start_client.setEnabled(false);\r\n               launch.setEnabled(true);\r\n           }\r\n       });\r\n\r\n       // Request\r\n       launch.setOnClickListener(new View.OnClickListener() {\r\n           @Override\r\n           public void onClick(View v) {\r\n               // Obtener los números a sumar\r\n               x =  new Double(val1.getText().toString());\r\n               y =  new Double(val2.getText().toString());\r\n\r\n               // Pedir a la clase cliente que lance la operación de sumar los dos números\r\n               result = client.launch(x, y, operation);\r\n\r\n               // Mostrar resultado en el layout\r\n               result_value.setText(String.valueOf(result));\r\n           }\r\n       });\r\n\r\n   }\r\n}\r\n\r\n\r\n```\r\n\r\nEl código cliente podemos verlo a continuación:\r\n\r\n```java\r\npackage com.red.lifka.rpc_android;\r\nimport android.util.Log;\r\nimport RPC.JSONRPCClient;\r\nimport RPC.JSONRPCException;\r\nimport RPC.JSONRPCParams;\r\npublic class Client {\r\n  private JSONRPCClient client;\r\n  private String host;\r\n\r\n  Client(String host){\r\n      Log.d(\"Info:\", \"Va a enlazar\"); //Debug\r\n      // Inicializar cliente\r\n      client = JSONRPCClient.create(host, JSONRPCParams.Versions.VERSION_2);\r\n      Log.d(\"Info:\", \"Enlazado\"); //Debug\r\n  }\r\n  public double launch(double v1, double v2, int operation){\r\n      // Set the connection timeout\r\n      // setConnectionTimeout(int connectionTimeout)\r\n      client.setConnectionTimeout(4000);\r\n      client.setSoTimeout(4000);\r\n      double result;\r\n      // operation => SIEMPRE VA A SUMAR EN ESTE EJEMPLO\r\n      // Intentamos lanzar la petición\r\n      try {\r\n          // Petición de Doubleresult = client.callDouble(\"suma\", v1, v2);\r\n      } catch (JSONRPCException e) {\r\n          e.printStackTrace();\r\n          result = -1;\r\n      }\r\n      return result;\r\n  }\r\n}\r\n```\r\n\r\nAsí quedaría el proyecto:\r\n\r\n![Imagen 1](http://i.imgur.com/BFXvT8b.png \"\") \r\n\r\n# 4 Referencias\r\n1. http://ccia.ei.uvigo.es/docencia/SCS/1011/transparencias/Tema2-2.pdf\r\n2. https://books.google.es/books?id=K9hnCJ_NGq4C&pg=PT500&lpg=PT500&dq=servicios+web+desde+android+arquitectura&source=bl&ots=KGDgREu7gJ&sig=unwp9GmfFOnubFQbhiCN4Z2HOig&hl=es&sa=X&ved=0ahUKEwiwuv2a2P7LAhVMXBoKHYHxCd0Q6AEIRDAG#v=onepage&q=servicios%20web%20desde%20android%20arquitectura&f=false\r\n3. http://www.w3c.es/Divulgacion/GuiasBreves/ServiciosWeb\r\n4. XML-RPC: http://xmlrpc.scripting.com/spec.html\r\n5. aXML-RPC: https://github.com/timroes/aXMLRPC\r\n6. Apache XML-RPC: http://ws.apache.org/xmlrpc/\r\n7. http://www.json.org/\r\n8. https://github.com/google/gson\r\n9. https://code.google.com/archive/p/android-xmlrpc/\r\n10. https://code.google.com/archive/p/android-json-rpc/\r\n11. https://opensource.org/licenses/mit-license.php\r\n12. https://code.google.com/archive/p/android-json-rpc/wikis/GettingStarted.wiki\r\n13. https://ws.apache.org/xmlrpc/client.html\r\n14. https://drive.google.com/file/d/0B_4Dc8dm9rLxVkgzR2JCVENGVkU/view?usp=sharing\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}